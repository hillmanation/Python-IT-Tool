import datetime, secrets, time, string
import src.assets.resources
from PyQt6.QtCore import *
from PyQt6.QtGui import QIntValidator, QIcon, QCursor, QPixmap
from PyQt6.QtWidgets import QLabel, QWidget, QGridLayout, QLineEdit, QCheckBox, QPushButton, QApplication, QToolTip, \
    QTabWidget, QTableWidget, QVBoxLayout, QGraphicsOpacityEffect


# noinspection PyUnresolvedReferences
class newuserform_ui(QWidget):  # Inherit from QWidget
    def __init__(self, main_app):
        super(newuserform_ui, self).__init__(main_app)  # Pass main_app as the parent
        self.easter_egg_opacity_effect = None
        self.easter_egg = None
        self.clear_button = None
        self.create_button = None
        self.button_tree = None
        self.group_add = None
        self.reveal_checkbox = None
        self.temp_password = None
        self.roulette_button = None
        self.edit_account_names = None
        self.account_names = None
        self.ISSO_check = None
        self.DTA_check = None
        self.AUD_check = None
        self.ADM_check = None
        self.zz_check = None
        self.User_check = None
        self.SSO_input = None
        self.edit_full_name = None
        self.full_name = None
        self.last_name = None
        self.first_name = None
        self.main_app = main_app
        self.setup_ui()

    def setup_ui(self):
        try:
            title = "New User"

            newuser_layout = QGridLayout(self)  # Set layout for self (which is a QWidget)

            newuser_label = QLabel("Create New User")
            font = newuser_label.font()
            font.setPointSize(15)
            newuser_label.setFont(font)
            newuser_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
            newuser_layout.addWidget(newuser_label, 0, 0, 1, 1)  # Row 0, Column 0, Span 1 row, 1 column

            # User entered name values
            self.first_name = QLineEdit()
            self.first_name.setPlaceholderText("Enter User First Name")
            self.first_name.textChanged.connect(self.set_full_name)  # Connect to the full_name generator
            newuser_layout.addWidget(self.first_name, 1, 0, 1, 4)

            self.last_name = QLineEdit()
            self.last_name.setPlaceholderText("Enter User Last Name")
            self.last_name.textChanged.connect(self.set_full_name)  # Connect to the full_name generator
            newuser_layout.addWidget(self.last_name, 1, 4, 1, 6)

            # Full name field generated by the above boxes by default
            self.full_name = QLineEdit()
            self.full_name.setReadOnly(True)
            self.full_name.setPlaceholderText("Full Name will autogenerate here")
            self.full_name.textChanged.connect(self.create_button_state)
            newuser_layout.addWidget(self.full_name, 2, 0, 1, 8)

            # Give user the ability to adjust the full name value (i.e. Smith1, Jr., III, etc.)
            self.edit_full_name = QCheckBox("Edit Full Name")
            edit_fn_tooltip = "Check to toggle ability to edit the Full Name field. (i.e. for Smith1, Jr., III, etc.)"
            self.edit_full_name.setToolTip(edit_fn_tooltip)
            # On toggle make the full_name box editable
            self.edit_full_name.stateChanged.connect(self.toggle_full_name_edit)
            newuser_layout.addWidget(self.edit_full_name, 2, 8, 1, 2)

            # Enter SSO for username selection
            self.SSO_input = QLineEdit()
            self.SSO_input.setPlaceholderText("Enter user SSO")
            self.SSO_input.setValidator(QIntValidator())
            self.SSO_input.setMaxLength(9)
            self.SSO_input.textChanged.connect(self.generate_account_names)
            newuser_layout.addWidget(self.SSO_input, 3, 0, 1, 5)

            # Define tooltip text for checkboxes
            account_type_tooltip = "If this box is checked, add this account type to account creation."
            self.User_check = QCheckBox("User")
            self.User_check.setChecked(True)
            self.User_check.stateChanged.connect(
                lambda: self.generate_account_tabs("User", self.User_check.isChecked()))
            self.User_check.setToolTip(account_type_tooltip)
            newuser_layout.addWidget(self.User_check, 3, 5, 1, 1)

            # Display the appropriate SSO checkbox for the environment found above
            if "evav" not in self.main_app.DOMAIN_NAME:
                self.ADM_check = QCheckBox(".ADM")
                self.ADM_check.stateChanged.connect(
                    lambda: self.generate_account_tabs(".ADM", self.ADM_check.isChecked()))
                self.ADM_check.setToolTip(account_type_tooltip)
                newuser_layout.addWidget(self.ADM_check, 3, 6, 1, 1)
            else:
                self.zz_check = QCheckBox("zz")
                self.zz_check.stateChanged.connect(
                    lambda: self.generate_account_tabs("zz", self.zz_check.isChecked()))
                self.zz_check.setToolTip(account_type_tooltip)
                newuser_layout.addWidget(self.zz_check, 3, 6, 1, 1)

            self.AUD_check = QCheckBox(".AUD")
            self.AUD_check.stateChanged.connect(
                lambda: self.generate_account_tabs(".AUD", self.AUD_check.isChecked()))
            self.AUD_check.setToolTip(account_type_tooltip)
            newuser_layout.addWidget(self.AUD_check, 3, 7, 1, 1)

            self.DTA_check = QCheckBox(".DTA")
            self.DTA_check.stateChanged.connect(
                lambda: self.generate_account_tabs(".DTA", self.DTA_check.isChecked()))
            self.DTA_check.setToolTip(account_type_tooltip)
            newuser_layout.addWidget(self.DTA_check, 3, 8, 1, 1)

            self.ISSO_check = QCheckBox(".ISSO")
            self.ISSO_check.stateChanged.connect(
                lambda: self.generate_account_tabs(".ISSO", self.ISSO_check.isChecked()))
            self.ISSO_check.setToolTip(account_type_tooltip)
            newuser_layout.addWidget(self.ISSO_check, 3, 9, 1, 1)

            self.account_names = QLineEdit()
            self.account_names.setReadOnly(True)
            self.account_names.setPlaceholderText("SamAccountNames to be created will be listed here")
            self.account_names.textChanged.connect(self.create_button_state)
            newuser_layout.addWidget(self.account_names, 4, 0, 1, 8)

            self.edit_account_names = QCheckBox("Edit Accounts")
            # On toggle make the account names box editable
            self.edit_account_names.stateChanged.connect(self.toggle_account_edit)
            newuser_layout.addWidget(self.edit_account_names, 4, 8, 1, 2)

            # Display a temporary password field generated with today's date and last 4 of SSO
            self.temp_password = QLineEdit()
            self.temp_password.setReadOnly(True)
            self.temp_password.setEchoMode(QLineEdit.EchoMode.Password)
            self.temp_password.setPlaceholderText("Temporary Password")
            newuser_layout.addWidget(self.temp_password, 5, 0, 1, 6)

            self.reveal_checkbox = QCheckBox("Show Password")
            self.reveal_checkbox.stateChanged.connect(self.reveal_password)
            newuser_layout.addWidget(self.reveal_checkbox, 5, 6, 1, 2)

            self.roulette_button = QPushButton("Password Roulette")
            self.roulette_button.clicked.connect(self.password_roulette)
            newuser_layout.addWidget(self.roulette_button, 5, 8, 1, 2)

            group_add_label = QLabel("Add Groups")
            font = group_add_label.font()
            font.setPointSize(15)
            group_add_label.setFont(font)
            group_add_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
            newuser_layout.addWidget(group_add_label, 6, 0, 1, 1)

            # QTabWidget for adding groups
            self.group_add = QTabWidget()
            user_tab = QTableWidget()
            self.group_add.addTab(user_tab, "User")
            newuser_layout.addWidget(self.group_add, 7, 0, 1, 8)

            # Widget to hold button tree
            self.button_tree = QWidget()
            button_layout = QVBoxLayout(self.button_tree)

            self.easter_egg = QLabel(self)
            ee_image = QPixmap(":/images/jake-head.png")
            self.easter_egg.setPixmap(ee_image)
            self.easter_egg.setScaledContents(True)
            self.easter_egg.setFixedSize(32, 32)

            # Set up opacity effect
            self.easter_egg_opacity_effect = QGraphicsOpacityEffect(self)
            self.easter_egg_opacity_effect.setOpacity(0.0)
            self.easter_egg.setGraphicsEffect(self.easter_egg_opacity_effect)

            # Connect click event to adjust opacity
            self.easter_egg.mousePressEvent = self.adjust_opacity_on_click

            button_layout.addWidget(self.easter_egg)

            self.create_button = QPushButton("Create Users")
            self.create_button.setEnabled(False)
            button_layout.addWidget(self.create_button)

            self.clear_button = QPushButton("Clear Form")
            self.clear_button.clicked.connect(self.clear_form)
            button_layout.addWidget(self.clear_button)
            
            button_layout.setAlignment(Qt.AlignmentFlag.AlignBottom)
            newuser_layout.addWidget(self.button_tree, 7, 8, 1, 2)
            newuser_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

            tab_index = self.main_app.tabs.addTab(self, title)  # Add self to tabs instead of newuser_tab
            self.main_app.tabs.setTabIcon(tab_index, QIcon(':/material-icons/user_add_icon.png'))
            self.main_app.tabs.setCurrentIndex(tab_index)

            self.temp_password.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.temp_password.customContextMenuRequested.connect(self.copy_password_to_clipboard)
        except Exception as e:
            print(f"The following error occurred: {e}")

    def set_full_name(self):
        # Update the full name based on the values in the first and last name fields
        if not self.edit_full_name.isChecked():  # If edit_full_name is not checked then change the value of full_name
            first = self.first_name.text()
            last = self.last_name.text()
            full = ""
            # Generate the full_name using the values entered in first_name and last_name
            if first == "" and last == "":
                full = ""
            elif first != "" and last != "":
                full = f"{last}, {first}"
            elif first != "":
                full = f"{first}"
            elif last != "":
                full = f"{last}"

            self.full_name.setText(full)

    def toggle_full_name_edit(self):
        if self.edit_full_name.isChecked():  # Toggle the ability to edit the full_name box
            self.full_name.setReadOnly(False)
        else:
            self.full_name.setReadOnly(True)

    def toggle_account_edit(self):
        if self.edit_account_names.isChecked():
            self.account_names.setReadOnly(False)
        else:
            self.account_names.setReadOnly(True)

    def generate_account_names(self):
        self.create_button_state()  # Enable or disable the 'Create Users' button
        try:
            if not self.edit_account_names.isChecked():  # Only do this if edit_account_names is not checked
                if self.SSO_input.text() == "":  # If text is fully removed from SSO input, set account_names box to ""
                    self.account_names.setText("")
                    self.temp_password.setText("")
                else:
                    account_list = []  # Define list for account names
                    # Evaluate which boxes are checked and need included in the list
                    if self.User_check.isChecked():
                        account_list.append(self.SSO_input.text())
                    if self.ADM_check is not None and self.ADM_check.isChecked():
                        account_list.append(f"{self.SSO_input.text()}.ADM")
                    if self.zz_check is not None and self.zz_check.isChecked():
                        account_list.append(f"zz{self.SSO_input.text()}")
                    if self.AUD_check.isChecked():
                        account_list.append(f"{self.SSO_input.text()}.AUD")
                    if self.DTA_check.isChecked():
                        account_list.append(f"{self.SSO_input.text()}.DTA")
                    if self.ISSO_check.isChecked():
                        account_list.append(f"{self.SSO_input.text()}.ISSO")
                    # Set the account_names box to the list content
                    self.account_names.setText(str(', '.join(account_list)))
                    self.generate_temp_password()
        except Exception as e:
            print(f"Error generating account names: {e}")

    def generate_account_tabs(self, name, state):  # Generate tabs for use with user group add
        if state:
            tab_exists = False
            for index in range(self.group_add.count()):
                if self.group_add.tabText(index) == name:
                    tab_exists = True
                    break
            if not tab_exists:
                self.group_add.addTab(QTableWidget(), name)
        else:
            index = -1
            for i in range(self.group_add.count()):
                if self.group_add.tabText(i) == name:
                    index = i
                    break
            if index != -1:
                self.group_add.removeTab(index)
        self.generate_account_names()  # Now adjust the SamAccountNames field if needed

    def generate_temp_password(self):
        today = datetime.date.today()
        ftoday = today.strftime("%Y%m%d")

        last4 = str(self.SSO_input.text()[-4:])  # Grab last 4 of the SSO_input
        temp_pass = f"P@ssword_{ftoday}_{last4}"
        self.temp_password.setText(temp_pass)

    def reveal_password(self):  # Toggle the Password blips
        if self.reveal_checkbox.isChecked():
            self.temp_password.setEchoMode(QLineEdit.EchoMode.Normal)
        else:
            self.temp_password.setEchoMode(QLineEdit.EchoMode.Password)

    def password_roulette(self):
        self.temp_password.setEchoMode(QLineEdit.EchoMode.Normal)
        if self.temp_password.text() != "":
            seed = self.temp_password.text()
        else:
            seed = "Rolling Password..."
            self.temp_password.setText("")
            QTimer.singleShot(4000, lambda: self.temp_password.setText(seed))

        # Toss the text from the above seed into a character array
        # then define our possible password characters
        char_list = [char for char in seed]
        key = string.ascii_letters + string.digits + "!@#$%^&*()-_=+[]{}|;:'\",.<>/?`~"

        for i in range(len(char_list)):
            start_time = time.time()
            while time.time() - start_time < 0.25:  # Continue for 1/4 second
                char_list[i] = secrets.choice(key)  # Select a random character from the key
                self.temp_password.setText(''.join(char_list))  # Update the temp_password text box
                QCoreApplication.processEvents()  # Allow the GUI to update
                # QTimer.singleShot(1000, lambda: None)

        if not self.password_meets_requirements(''.join(char_list)):
            self.password_roulette()  # If the password does not meet the requirements, re-roll it

        if not self.reveal_checkbox.isChecked():
            self.temp_password.setEchoMode(QLineEdit.EchoMode.Password)

    def password_meets_requirements(self, password):
        # Check if the password meets the specified requirements
        has_upper = any(char.isupper() for char in password)
        has_lower = any(char.islower() for char in password)
        has_digit = any(char.isdigit() for char in password)
        has_special = any(char in "!@#$%^&*()-_=+[]{}|;:'\",.<>/?`~" for char in password)

        return has_upper and has_lower and has_digit and has_special

    def copy_password_to_clipboard(self, event):
        if self.temp_password.text() != "":
            clipboard = QApplication.clipboard()
            clipboard.setText(self.temp_password.text())

            # Display a tooltip near the mouse cursor
            mouse_pos = QCursor.pos()
            QToolTip.showText(mouse_pos, "Password Copied!", self.temp_password)

    def adjust_opacity_on_click(self, event):
        # Increase opacity by 10% on each click
        current_opacity = self.easter_egg_opacity_effect.opacity()
        if current_opacity < 0.9999:
            new_opacity = current_opacity + 0.1
            self.easter_egg_opacity_effect.setOpacity(new_opacity)
        else:
            self.easter_egg.setToolTip("Congrats, you found me!....\nNow go back to work?")

    def create_button_state(self):
        # Check conditions and enable/disable the "Create Users" button accordingly
        conditions_met = all([
            self.first_name.text(),
            self.last_name.text(),
            self.full_name.text(),
            self.SSO_input.text(),
            self.account_names.text()
        ])
        self.create_button.setEnabled(conditions_met)

    def clear_form(self):
        # Clear text fields
        self.first_name.clear()
        self.last_name.clear()
        self.full_name.clear()
        self.SSO_input.clear()
        self.account_names.clear()
        self.temp_password.clear()

        # Reset checkboxes
        self.User_check.setChecked(True)
        if "evav" not in self.main_app.DOMAIN_NAME:
            self.ADM_check.setChecked(False)
        else:
            self.zz_check.setChecked(False)
        self.AUD_check.setChecked(False)
        self.DTA_check.setChecked(False)
        self.ISSO_check.setChecked(False)

        # Uncheck edit checkboxes
        self.edit_full_name.setChecked(False)
        self.edit_account_names.setChecked(False)

        # Uncheck show password checkbox
        self.reveal_checkbox.setChecked(False)
